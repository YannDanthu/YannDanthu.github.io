= Un Sens'it, un Rolling Spider et Meteor sont dans un bateau
:hp-tags: Sensit, IoT, Sigfox, Meteor, Parrot, Rolling Spider
:published_at: 2015-08-31
:url-blogpost: http://anthonnyquerouil.fr/2015/08/24/Sensit-mon-petit-objet-connecte.html

Comme vous l'avez peut-être lu dans mon précédent billet 
{url-blogpost}, j'ai récemment fait l'acquisition d'un Sens'it. 

image::https://cloud.githubusercontent.com/assets/2006548/9440843/9e9e12bc-4a72-11e5-9485-cc94a6735fbf.JPG[title=Le Sens'it]

J'ai aussi depuis peu un Rolling-spider que je m'étais procuré dans le but de le controller via un peu de code JS (tout ça à cause de http://twitter.com/k33g_org[@k33g_org]). L'heure est venue de mixer tout ça !

image::https://pbs.twimg.com/media/CNiIQfqWoAAhK9m.jpg[title=Le trio gagnant]

== L'objectif

L'objectif est plutôt simple, double cliquer sur le Sens'it et faire décoller le Rolling-spider.

Pour ce faire, voici ce qu'il nous faut :

* Un Sens'it,
* Un Parrot Rolling Spider,
* Un framework JS permettant de controller le spider (on utilisera https://github.com/voodootikigod/node-rolling-spider[node-rolling-spider]),
* Un peu de Meteor pour lier le tout.


== L'architecture


image::https://cloud.githubusercontent.com/assets/2006548/9587833/f979b92c-5024-11e5-9fbf-20a14b2594b8.png[title=Architecture cible]

1. Le Sens'it va transmettre un message sur le réseau SIGFOX,
2. Les serveurs SIGFOX vont communiquer aux serveurs AXIBLE qu'un message button a été envoyé,
3. AXIBLE va appelé l'URL de Callback que nous aurons défini dans l'interface d'administration,
4. Ce callback pointera sur une application *sensit.meteor.com* que nous aurons déployée au préalable,
5. Cette dernière enregistrera une trace de l'appel dans une collection Mongo,
6. Notre application cliente établira une connexion DDP avec l'application *sensit.meteor.com*, et observera les changements effectués sur cette collection,
7. Au premier changement détecté, on décolle.

== Etape 1 : sensit.meteor.com

Dans l'interface Sens'it, nous allons spécifier une URL de callback pour les notifications de type *button*.

Pour rappel, ce callback est appelé via un GET et peut recevoir en query param certaines valeurs (via des variables {{my_var}}) :

* device_id
* device_serial_number
* sensor_id
* mode
* notification_type
* data
* date

Nous pouvons donc définir l'URL suivante :

----
http://sensit.meteor.com/sensit-callback/button?device_id={{device_id}}&device_serial_number={{device_serial_number}}&sensor_id={{sensor_id}}&mode={{mode}}&notification_type={{notification_type}}&data={{data}}&date={{date}}
----

image::https://cloud.githubusercontent.com/assets/2006548/9629320/160ef888-5172-11e5-895a-460308bc2a5c.png[]

Nous pouvons créer notre application *meteor* :
[source, shell]
----
meteor create sensit-callback
cd sensit-callback
meteor remove autopublish insecure
rm sensit-callback.*
mkdir server
touch server/main.js
----

Pour la gestion des routes, on d'utilisera *iron-router* :
[source, javascript]
----
meteor add iron:router
----


Commençons par créer une collection `notification` qui aura pour but de stocker les différentes notifications reçues.

[source, javascript, title=server/main.js]
----
Notification = new Meteor.Collection("notification");
----

Il faut ensuite définir notre endpoint qui répondra à l'appel du callback.

[source, javascript, title=server/main.js]
----
Router.route('/sensit-callback/:type', {where: 'server'})
  .get(function () {
    if (['temperature', 'motion', 'button'].indexOf(this.params.type) < 0)
      throw new Error('Invalid type');

    var notification = _.extend({type: this.params.type}, this.params.query, {data: JSON.parse(this.params.query.data)});

    Notification.insert(notification);
    this.response.end('notification ' + notification.type + ' saved\n');
  });
----

Nous définissons une route `/sensit-callback/:type` dans laquelle `:type` peut prendre les valeurs `['temperature', 'motion', 'button']`. 

On construit ensuite un objet `notification` à partir du `type` et des queryParam (on force la conversion en JSON du paramètre `data` car c'est un objet JSON stringifié).

Enfin on insert notre `notification` en base et on répond en confirmant l'enregistrement.

Pour que les informations présentes dans notre collection soient accessibles par notre "client", il faut les publier :

[source, javascript]
----
Meteor.publish("remote-temperature", function (argument) {
  return Notification.find({type: 'temperature'});
});
Meteor.publish("remote-motion", function (argument) {
  return Notification.find({type: 'motion'});
});
Meteor.publish("remote-button", function (argument) {
  return Notification.find({type: 'button'});
});
----

